
(define (map proc items)
	(if (null? items)
		'()
		(cons (proc (car items))
			(map proc (cdr items)))))

			
(define-macro (deftree id root)
	`(define ,id (make-behaviour-tree ,root 'unknown))) 
	
(define (make-behaviour-tree root state)
	(define construct (lambda ()
		(begin (root 'construct) (set! state 'working) state)))
	(define execute (lambda ()
		(begin (set! state (root 'execute)) state)))
	(define destruct (lambda ()
		(begin (root 'destruct) (set! state 'unknown) state)))
	(define after-execute (lambda ()
		(begin 
			(cond
				((eq? state 'success) (begin (destruct) 'success))
				((eq? state 'failure) (begin (destruct) 'failure))
				(else state)))))
	(define step-tree (lambda ()
		(begin
			(cond
				((eq? state 'working) (begin (execute) (after-execute)))
				((eq? state 'success) (destruct))
				((eq? state 'failure) (destruct))
				((eq? state 'unknown) (begin (construct) (step-tree))))
			)))
	step-tree) 
	
(define-macro (multiple-child-node name proc cons-proc exec-proc dest-proc)
	`(begin 
		(define (,name children) (,proc (map (lambda (child) (eval child)) children)))
		(define (,proc children)
			(let 
				((cchild '())
				(rchild '()))
				
				(define step-child (lambda ()
					(begin
						(cond
							((pair? rchild)
								(begin
									(set! cchild (car rchild))
									(set! rchild (cdr rchild))
									#t))
							((not (null? rchild))
								(begin
									(set! cchild rchild)
									(set! rchild '())
									#t))
							(else 
								(begin
									(set! cchild '())
									#f))))))

				(define exec-child (lambda (func)
					(begin
						(if (not (null? cchild)) 
							(cchild func)
							'success))))

				(define dispatch (lambda (m) 
					(begin
						(cond
							((eq? m 'construct) (construct))
							((eq? m 'execute) (execute))
							((eq? m 'destruct) (destruct))
							(else (error "Unkown request on node" m))))))

				(define construct ,cons-proc)
				(define execute ,exec-proc)
				(define destruct ,dest-proc)

				dispatch))))

(multiple-child-node sequence make-sequence
	 (lambda () 
		(begin
			(set! rchild children)
			(step-child)
			(exec-child 'construct)))

	(lambda ()
		(define internal (lambda ()
			(let ((r 'unkown))
				(set! r (exec-child 'execute))
				(if	(eq? r 'success) 
					(begin 
						(exec-child 'destruct) 
						(if (step-child) 
							(begin 
								(exec-child 'construct) 
								(internal))
							'success))
					r))))
		(internal))
		
	(lambda () 
		(begin 
			(exec-child 'destruct)
			(set! cchild '())
			(set! rchild '()))))

(multiple-child-node selector make-selector
	(lambda () 
		(set! rchild children)
		(step-child)
		(exec-child 'construct))
		
	(lambda ()
		(define internal (lambda ()
			(let ((r 'unkown))
				(set! r (exec-child 'execute))
				(if (eq? r 'failure)
					(begin 
						(exec-child 'destruct) 
						(if (step-child) 
							(begin 
								(exec-child 'construct)
								(internal))
							'failure))
					r))))
		(internal))

	(lambda () 
		(exec-child 'destruct)
		(set! cchild '())
		(set! rchild '())))

(multiple-child-node parallel make-parallel
	(lambda () 
		(set! rchild children)
		(define internal (lambda ()
			(if (step-child) 
				(begin 
					(exec-child 'construct)
					(internal)))))
		(internal))

	(lambda () 
		(set! rchild children)
		(define internal (lambda (s t)
			(if (step-child)
				(let ((r (exec-child 'execute)))
					(cond 
						((eq? r 'failure) 'failure)
						((eq? r 'working) (internal s (+ t 1)))
						((eq? r 'success) (internal (+ s 1) (+ t 1)))))
				(if (= s t) 'success 'working))))
		(internal 0 0))

	(lambda () 
		(set! rchild children)
		(define internal (lambda ()
			(if (step-child) 
				(begin 
					(exec-child 'destruct)
					(internal)))))
		(internal)))
		
(multiple-child-node dynselector make-dynselector
	(lambda () 'unknown)
	(lambda () 'failure)
	(lambda () 'unknown))

(define decorator
	(lambda (dec_id arg child) ('failure))
)

(define (action proc)
	
	(define construct (lambda () 
		'unknown))

	(define execute (lambda () 
		 (proc)))

	(define destruct (lambda () 
		'unknown))
		
	(define act_dispatch (lambda (m)
		(begin 
			(cond
				((eq? m 'construct) (construct))
				((eq? m 'execute) (execute))
				((eq? m 'destruct) (destruct))
				(else (error "Unkown Request on action" m))))))
	act_dispatch)

(define tree
	(lambda (id) ('failure))
)

(define defact
	(lambda (id settings arguments) '())
)

(define defdec
	(lambda (id settings arguments) '())
)

